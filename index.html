<!doctype html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fábio</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root{
      --bg:#000;
      --glass: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --shadow: 0 35px 120px rgba(0,0,0,.78);
      --ease: cubic-bezier(.2,.9,.2,1);
    }

    html,body{ height:100%; background:var(--bg); }
    body{ overflow:hidden; }

    /* Canvas FX */
    #fx{
      position:fixed; inset:0;
      z-index:0;
      opacity: 0;
      transform: scale(1.02);
      filter: blur(0px);
      transition: opacity 800ms var(--ease), transform 1200ms var(--ease), filter 900ms var(--ease);
    }
    body.scene-reveal #fx{
      opacity: 1;
      transform: scale(1);
      filter: blur(0px);
    }

    /* Cinematic vignette */
    .vignette{
      position:fixed; inset:0;
      z-index:1;
      pointer-events:none;
      opacity:0;
      transition: opacity 900ms var(--ease);
      background:
        radial-gradient(1100px 850px at 50% 16%, rgba(255,255,255,0.08), transparent 58%),
        radial-gradient(900px 650px at 18% 82%, rgba(124,58,237,0.12), transparent 62%),
        radial-gradient(900px 650px at 84% 78%, rgba(0,209,255,0.12), transparent 62%),
        radial-gradient(1400px 1000px at 50% 50%, transparent 30%, rgba(0,0,0,0.88) 76%, rgba(0,0,0,0.98) 100%);
    }
    body.scene-reveal .vignette{ opacity:1; }

    /* Layout */
    .stage{
      position:relative;
      z-index:2;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 54px 18px;
      text-align:center;
    }

    /* Top text */
    .hello{
      font-weight: 900;
      letter-spacing: -0.04em;
      line-height: 0.92;
      text-shadow: 0 22px 70px rgba(0,0,0,.75);
      transform: translateY(0);
      opacity: 1;
      transition: transform 900ms var(--ease), opacity 650ms var(--ease);
    }
    body.scene-open .hello{
      transform: translateY(-10px);
      opacity: 0.92;
    }

    /* Gift */
    .gift-wrap{
      --w: 260px;
      --lidH: 78px;
      --boxH: 176px;
      --r: 24px;
      width: var(--w);
      height: calc(var(--lidH) + var(--boxH));
      position:relative;
      margin: 34px auto 0;
      cursor:pointer;
      transform: translateZ(0);
      filter: drop-shadow(0 28px 85px rgba(0,0,0,.75));
      transition: transform 500ms var(--ease), opacity 420ms var(--ease), filter 700ms var(--ease);
      will-change: transform, opacity;
    }
    .gift-wrap:hover{ transform: translateY(-4px) scale(1.015); }
    .gift-wrap:active{ transform: translateY(-2px) scale(1.01); }
    .gift-wrap.gone{
      opacity:0;
      transform: translateY(14px) scale(0.96);
      filter: drop-shadow(0 0 0 rgba(0,0,0,0));
      pointer-events:none;
    }

    .gift-lid{
      position:absolute; inset:0 0 auto 0;
      height: var(--lidH);
      border-radius: var(--r) var(--r) 18px 18px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.03)),
        linear-gradient(135deg, #0b1322, #050812);
      border: 1px solid rgba(255,255,255,.13);
      overflow:hidden;
      transform-origin: 16% 88%;
      transform: rotate(0deg) translateY(0);
      transition: transform 650ms var(--ease);
      box-shadow: 0 18px 45px rgba(0,0,0,.55) inset;
    }
    .gift-lid::before{
      content:"";
      position:absolute; left:0; top:50%;
      transform: translateY(-50%);
      width:100%; height: 18px;
      background: linear-gradient(90deg,#ff004c,#ff9a00,#ffe600,#00ff85,#00d1ff,#7c3aed,#ff00ea,#ff004c);
      opacity: .95;
      filter: saturate(1.1);
    }
    .gift-lid::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(220px 100px at 22% 30%, rgba(255,255,255,.18), transparent 60%);
      pointer-events:none;
      mix-blend-mode: screen;
      opacity: .75;
    }

    .gift-box{
      position:absolute; inset:auto 0 0 0;
      height: var(--boxH);
      top: var(--lidH);
      border-radius: 18px 18px var(--r) var(--r);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03)),
        linear-gradient(135deg, #050812, #02030a);
      border: 1px solid rgba(255,255,255,.13);
      overflow:hidden;
      box-shadow:
        0 20px 70px rgba(0,0,0,.55),
        0 -18px 60px rgba(255,255,255,.06) inset;
    }
    .gift-box::before{
      content:"";
      position:absolute;
      left:50%; top:-60px;
      transform: translateX(-50%);
      width: 30px;
      height: calc(100% + 120px);
      border-radius: 999px;
      background: linear-gradient(180deg,#ff004c,#7c3aed);
      opacity: .95;
      filter: saturate(1.15);
    }
    .gift-box::after{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(270px 190px at 18% 22%, rgba(255,255,255,.12), transparent 60%),
        radial-gradient(320px 240px at 76% 84%, rgba(0,209,255,.10), transparent 60%);
      pointer-events:none;
      mix-blend-mode: screen;
      opacity: .6;
    }

    .bow{
      position:absolute;
      left:50%; top: 10px;
      transform: translateX(-50%);
      width: 104px; height: 60px;
      pointer-events:none;
      filter: drop-shadow(0 14px 22px rgba(0,0,0,.35));
    }
    .bow::before,.bow::after{
      content:"";
      position:absolute;
      width: 52px; height: 42px;
      border-radius: 999px 999px 999px 20px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.38), transparent 55%),
        linear-gradient(135deg,#ff004c,#7c3aed);
    }
    .bow::before{ left:0; transform: rotate(-12deg); }
    .bow::after { right:0; transform: rotate(12deg) scaleX(-1); }

    .knot{
      position:absolute;
      left:50%; top: 24px;
      transform: translateX(-50%);
      width: 18px; height: 18px;
      border-radius:999px;
      background: linear-gradient(135deg, rgba(255,255,255,.75), rgba(255,255,255,.22));
      border: 1px solid rgba(255,255,255,.25);
      box-shadow: 0 12px 20px rgba(0,0,0,.35);
    }

    /* hover: semi-open */
    .gift-wrap:hover .gift-lid{
      transform: rotate(-18deg) translate(-2px,-6px);
    }

    /* open */
    .gift-wrap.open .gift-lid{
      transform: rotate(-82deg) translate(-10px,-22px);
    }

    /* reveal text: only appears after click */
    .reveal{
      margin-top: 22px;
      opacity:0;
      transform: translateY(20px) scale(.985);
      transition: opacity 650ms var(--ease), transform 950ms var(--ease), filter 800ms var(--ease);
      filter: blur(10px);
      pointer-events:none;
    }
    body.scene-reveal .reveal{
      opacity: 1;
      transform: translateY(0) scale(1);
      filter: blur(0px);
      pointer-events:auto;
    }

    .revealCard{
      display:inline-block;
      padding: 18px 22px;
      border-radius: 26px;
      background: var(--glass);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      max-width: min(780px, 92vw);
    }

    /* Rainbow button */
    .rainbow-btn{
      position: relative;
      padding: 14px 22px;
      border-radius: 16px;
      background: rgba(0,0,0,.72);
      color:#fff;
      font-weight: 900;
      letter-spacing:.02em;
      transform: translateZ(0);
      outline:none;
      box-shadow: 0 18px 65px rgba(0,0,0,.68);
    }
    .rainbow-btn::before{
      content:"";
      position:absolute;
      inset:-3px;
      border-radius: 18px;
      background: conic-gradient(from 0deg,#ff004c,#ff9a00,#ffe600,#00ff85,#00d1ff,#7c3aed,#ff00ea,#ff004c);
      animation: spin 1.0s linear infinite;
      z-index:-2;
      filter: saturate(1.15) blur(.2px);
    }
    .rainbow-btn::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius: 16px;
      background: rgba(0,0,0,.78);
      z-index:-1;
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    /* Floating button (JS controls exact motion) */
    #floatingBtn{
      position:fixed;
      left: 12vw;
      top: 70vh;
      z-index: 3;
      display:none;
      will-change: transform, left, top, filter;
      filter: drop-shadow(0 18px 55px rgba(0,0,0,.7));
      transition: opacity 600ms var(--ease);
      opacity: 0;
    }
    body.scene-reveal #floatingBtn{
      display:block;
      opacity: 1;
    }

    /* Smooth scene cut feel */
    .sceneCurtain{
      position:fixed; inset:0;
      z-index: 4;
      pointer-events:none;
      opacity:0;
      background: radial-gradient(900px 700px at 50% 30%, rgba(255,255,255,.06), transparent 55%),
                  rgba(0,0,0,.65);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      transition: opacity 650ms var(--ease);
    }
    body.scene-open .sceneCurtain{ opacity: 1; }
    body.scene-reveal .sceneCurtain{ opacity: 0; }

    @media (prefers-reduced-motion: reduce){
      #fx,.vignette,.hello,.gift-wrap,.gift-lid,.reveal,.rainbow-btn::before,.sceneCurtain{
        transition:none !important; animation:none !important;
      }
    }
  </style>
</head>

<body class="text-white">
  <canvas id="fx"></canvas>
  <div class="vignette"></div>
  <div class="sceneCurtain"></div>

  <!-- música (mete musica.mp3 na pasta) -->
  <audio id="music" src="musica.mp3" preload="auto" crossorigin="anonymous"></audio>

  <main class="stage">
    <div>
      <h1 class="hello text-6xl sm:text-7xl md:text-8xl">
        olá Fábio<span class="opacity-80">...</span>
      </h1>

      <div id="gift" class="gift-wrap" aria-label="Presente">
        <div class="gift-lid">
          <div class="bow"><div class="knot"></div></div>
        </div>
        <div class="gift-box"></div>
      </div>

      <div class="reveal" id="reveal">
        <div class="revealCard">
          <p class="text-2xl sm:text-3xl md:text-4xl font-extrabold leading-tight">
            parabéns! ganhaste um dia de bolos e ganza
          </p>
        </div>
      </div>
    </div>
  </main>

  <div id="floatingBtn" aria-hidden="true">
    <button class="rainbow-btn active:scale-[0.98] transition-transform" type="button">
      aceitar
    </button>
  </div>

  <script>
    // ----------------------------
    // Canvas (background + particles + audio visualizer)
    // ----------------------------
    const canvas = document.getElementById("fx");
    const ctx = canvas.getContext("2d", { alpha: true });

    let W=0, H=0, DPR=1;

    function resize(){
      DPR = Math.min(2, window.devicePixelRatio || 1);
      canvas.width  = Math.floor(window.innerWidth  * DPR);
      canvas.height = Math.floor(window.innerHeight * DPR);
      canvas.style.width  = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      ctx.setTransform(DPR,0,0,DPR,0,0);
      W = window.innerWidth;
      H = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    // ----------------------------
    // WebAudio: music + analyser + SFX (synth)
    // ----------------------------
    const audioEl = document.getElementById("music");

    let audioCtx = null;
    let analyser = null;
    let freqData = null;
    let timeData = null;
    let master = null;
    let musicGain = null;
    let audioReady = false;

    async function initAudio(){
      if(audioReady) return;

      const Ctx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new Ctx();

      // Master
      master = audioCtx.createGain();
      master.gain.value = 0.95;
      master.connect(audioCtx.destination);

      // Music chain
      const src = audioCtx.createMediaElementSource(audioEl);
      musicGain = audioCtx.createGain();
      musicGain.gain.value = 0.95;

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = 0.86;

      src.connect(musicGain);
      musicGain.connect(analyser);
      analyser.connect(master);

      freqData = new Uint8Array(analyser.frequencyBinCount);
      timeData = new Uint8Array(analyser.fftSize);

      audioReady = true;
    }

    async function startMusic(){
      await initAudio();
      if(audioCtx.state === "suspended") await audioCtx.resume();
      try{
        audioEl.currentTime = 0;
        await audioEl.play();
      }catch(e){
        console.warn("Erro a tocar musica.mp3:", e);
      }
    }

    // Simple pro-feeling SFX (no files): whoosh + sparkle + thump
    function sfxWhoosh(){
      if(!audioReady) return;
      const t = audioCtx.currentTime;

      const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.25, audioCtx.sampleRate);
      const data = noiseBuf.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);

      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuf;

      const biq = audioCtx.createBiquadFilter();
      biq.type = "bandpass";
      biq.frequency.setValueAtTime(450, t);
      biq.frequency.exponentialRampToValueAtTime(1600, t+0.18);
      biq.Q.value = 0.7;

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.35, t+0.04);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.22);

      noise.connect(biq);
      biq.connect(g);
      g.connect(master);

      noise.start(t);
      noise.stop(t+0.24);
    }

    function sfxSparkle(){
      if(!audioReady) return;
      const t = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(1200, t);
      osc.frequency.exponentialRampToValueAtTime(2400, t+0.06);
      osc.frequency.exponentialRampToValueAtTime(900,  t+0.14);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.22, t+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.16);

      const hp = audioCtx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 800;

      osc.connect(hp);
      hp.connect(g);
      g.connect(master);

      osc.start(t);
      osc.stop(t+0.18);
    }

    function sfxThump(){
      if(!audioReady) return;
      const t = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.exponentialRampToValueAtTime(55, t+0.12);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.45, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.14);

      osc.connect(g);
      g.connect(master);

      osc.start(t);
      osc.stop(t+0.16);
    }

    // duck music briefly for SFX clarity (tiny “pro trick”)
    function duckMusic(ms=220, depth=0.65){
      if(!musicGain) return;
      const t = audioCtx.currentTime;
      const cur = musicGain.gain.value;

      musicGain.gain.cancelScheduledValues(t);
      musicGain.gain.setValueAtTime(cur, t);
      musicGain.gain.exponentialRampToValueAtTime(Math.max(0.001, cur*depth), t + 0.03);
      musicGain.gain.exponentialRampToValueAtTime(cur, t + (ms/1000));
    }

    // ----------------------------
    // FX particles (beat reactive)
    // ----------------------------
    const particles = [];
    const rand = (a,b)=>a+Math.random()*(b-a);

    function spawnParticles(x,y,count,energy=1){
      for(let i=0;i<count;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(0.9, 3.4) * (0.75 + energy*0.9);
        particles.push({
          x, y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd - rand(0.3,1.2),
          r: rand(1.0, 2.8) * (0.9 + energy*0.5),
          life: rand(70, 150),
          t: 0,
          hue: rand(0, 360),
          tw: rand(0.5, 1.4),
        });
      }
    }

    function getEnergy(){
      if(!audioReady || !analyser) return 0;
      analyser.getByteFrequencyData(freqData);
      let sum = 0;
      // foco em graves+médios (mais “punch”)
      const n = Math.floor(freqData.length * 0.35);
      for(let i=0;i<n;i++) sum += freqData[i];
      return (sum / n) / 255; // 0..1
    }

    // Premium visualizer: circular bars + waveform “sheen”
    function drawVisualizer(now, energy){
      if(!audioReady || !analyser) return;

      analyser.getByteFrequencyData(freqData);
      analyser.getByteTimeDomainData(timeData);

      const cx = W/2;
      const cy = H*0.46;
      const baseR = Math.min(W,H) * 0.19;
      const pulse = baseR * (0.06 + energy * 0.30);

      // soft glow wash
      const halo = ctx.createRadialGradient(cx, cy, baseR*0.4, cx, cy, baseR*1.7);
      halo.addColorStop(0, `rgba(255,255,255,${0.03 + energy*0.08})`);
      halo.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = halo;
      ctx.fillRect(0,0,W,H);

      // circular bars
      const bars = 170;
      const start = -Math.PI * 0.92;
      const end   =  Math.PI * 0.92;
      const step = (end-start)/bars;

      ctx.save();
      ctx.translate(cx, cy);

      for(let i=0;i<bars;i++){
        const idx = Math.floor((i/bars) * (freqData.length * 0.55));
        const v = freqData[idx]/255;

        const a = start + i*step + Math.sin(now*0.0007)*0.002;
        const len = (baseR*0.12) + v*(baseR*0.78) + energy*(baseR*0.18);

        const x1 = Math.cos(a) * (baseR + pulse);
        const y1 = Math.sin(a) * (baseR + pulse);
        const x2 = Math.cos(a) * (baseR + pulse + len);
        const y2 = Math.sin(a) * (baseR + pulse + len);

        const hue = ((i/bars)*360 + now*0.02) % 360;
        const alpha = 0.12 + v*0.62;

        ctx.strokeStyle = `hsla(${hue}, 95%, 62%, ${alpha})`;
        ctx.lineWidth = 2.2;
        ctx.lineCap = "round";

        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();
      }

      // core ring
      ctx.strokeStyle = `rgba(255,255,255,${0.08 + energy*0.28})`;
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.arc(0,0, baseR*0.92 + pulse*0.25, 0, Math.PI*2);
      ctx.stroke();

      // waveform sheen (thin ribbon)
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = `rgba(255,255,255,${0.10 + energy*0.25})`;
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      const waveCount = 240;
      for(let i=0;i<waveCount;i++){
        const ti = Math.floor((i/waveCount) * (timeData.length-1));
        const n = (timeData[ti] - 128) / 128; // -1..1
        const a = start + (i/(waveCount-1))*(end-start);
        const rr = baseR*0.78 + pulse*0.12 + n*(baseR*0.08 + energy*baseR*0.06);
        const x = Math.cos(a)*rr;
        const y = Math.sin(a)*rr;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    let activeFX = false;
    let lastBeat = 0;

    function tick(now){
      ctx.clearRect(0,0,W,H);

      if(activeFX){
        // ambient gradient drift
        const gx = W*(0.5 + Math.sin(now*0.00025)*0.12);
        const gy = H*(0.25 + Math.cos(now*0.00022)*0.10);
        const g1 = ctx.createRadialGradient(gx, gy, 0, gx, gy, W*0.85);
        g1.addColorStop(0, "rgba(255,255,255,0.05)");
        g1.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = g1;
        ctx.fillRect(0,0,W,H);

        const energy = getEnergy();
        drawVisualizer(now, energy);

        // beat-ish spawns (threshold + cooldown)
        if(energy > 0.22 && (now - lastBeat) > 140){
          lastBeat = now;
          spawnParticles(rand(W*0.18, W*0.82), rand(H*0.10, H*0.55), 10, energy);
        }

        // particles
        for(let i=particles.length-1;i>=0;i--){
          const p = particles[i];
          p.t++;
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.992;
          p.vy = p.vy*0.992 + 0.012;

          const fade = 1 - (p.t/p.life);
          const alpha = Math.max(0, fade) * 0.9;

          ctx.beginPath();
          ctx.fillStyle = `hsla(${p.hue}, 95%, 65%, ${alpha})`;
          ctx.arc(p.x, p.y, p.r + Math.sin((p.t*0.12)*p.tw)*0.32, 0, Math.PI*2);
          ctx.fill();

          if(p.t >= p.life) particles.splice(i,1);
        }
      }

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // ----------------------------
    // Scene choreography (open -> cut -> reveal)
    // ----------------------------
    const gift = document.getElementById("gift");
    const floating = document.getElementById("floatingBtn");
    const btn = floating.querySelector("button");

    let opened = false;

    function domBurstFromGift(){
      const r = gift.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top + 28;
      spawnParticles(cx, cy, 140, 1);
    }

    gift.addEventListener("click", async () => {
      if(opened) return;
      opened = true;

      await initAudio();
      if(audioCtx.state === "suspended") await audioCtx.resume();

      // Stage 1: open scene
      document.body.classList.add("scene-open");

      // SFX: whoosh + sparkle + thump (com duck)
      duckMusic(260, 0.55);
      sfxWhoosh();
      setTimeout(()=>{ duckMusic(220,0.60); sfxThump(); }, 90);
      setTimeout(()=>{ duckMusic(220,0.62); sfxSparkle(); }, 150);

      // Music start
      startMusic();

      // Open lid
      gift.classList.add("open");

      // micro impact
      gift.animate(
        [
          { transform: "translateY(0) scale(1)" },
          { transform: "translateY(-5px) scale(1.025)" },
          { transform: "translateY(0) scale(1)" }
        ],
        { duration: 520, easing: "cubic-bezier(.2,.9,.2,1)" }
      );

      // Prepare FX
      activeFX = true;
      domBurstFromGift();

      // Stage 2: "scene cut" then reveal
      setTimeout(()=>{
        // vanish gift to avoid "same page" feel
        gift.classList.add("gone");
      }, 620);

      setTimeout(()=>{
        document.body.classList.add("scene-reveal");
        // little extra burst in the middle for the reveal
        spawnParticles(W/2, H*0.30, 120, 1.2);
        startFloating();
      }, 760);
    });

    // ----------------------------
    // Floating button: smooth, organic, “alive”
    // ----------------------------
    let x = window.innerWidth * 0.12;
    let y = window.innerHeight * 0.70;
    let vx = 1.35;
    let vy = -1.05;

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function startFloating(){
      x = window.innerWidth * 0.12;
      y = window.innerHeight * 0.70;
      vx = 1.45; vy = -1.10;

      let last = performance.now();

      function step(now){
        const dt = Math.min(34, now-last);
        last = now;

        // gentle wind + music energy influence
        const energy = getEnergy();
        const windX = Math.sin(now*0.00075) * (0.22 + energy*0.28);
        const windY = Math.cos(now*0.00090) * (0.18 + energy*0.22);

        x += (vx + windX) * (dt*0.06);
        y += (vy + windY) * (dt*0.06);

        const pad = 18;
        const bw = btn.offsetWidth || 140;
        const bh = btn.offsetHeight || 52;

        // bounce
        if(x < pad){ x = pad; vx *= -1; sfxSparkle(); }
        if(y < pad){ y = pad; vy *= -1; sfxSparkle(); }
        if(x > window.innerWidth - bw - pad){ x = window.innerWidth - bw - pad; vx *= -1; sfxSparkle(); }
        if(y > window.innerHeight - bh - pad){ y = window.innerHeight - bh - pad; vy *= -1; sfxSparkle(); }

        // non-robotic drift
        vx = clamp(vx + Math.sin(now*0.0011)*0.002, -2.4, 2.4);
        vy = clamp(vy + Math.cos(now*0.0013)*0.002, -2.4, 2.4);

        floating.style.left = x + "px";
        floating.style.top  = y + "px";
        floating.style.transform =
          `translateZ(0) rotate(${Math.sin(now*0.0012)*(1.6+energy*1.2)}deg) scale(${1 + energy*0.05})`;

        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    window.addEventListener("resize", () => {
      resize();
      if(opened) startFloating();
    });
  </script>
</body>
</html>
